name: Deploy to Production

on:
  push:
    branches:
      - main
  workflow_dispatch: # Дозволяє запускати вручну через GitHub Actions UI

jobs:
  test-and-build:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Cache Python dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('backend/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install Python dependencies
        working-directory: ./backend
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-asyncio httpx aiosqlite asyncpg

      - name: Run Python linting
        working-directory: ./backend
        run: |
          pip install flake8 black
          # Check code style (non-blocking)
          black --check . || true
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics || true

      - name: Test backend imports
        working-directory: ./backend
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          JWT_SECRET: ${{ secrets.JWT_SECRET || 'test-secret-key-for-ci' }}
          APP_ENV: test
        run: |
          if [ -z "$DATABASE_URL" ]; then
            echo "Warning: DATABASE_URL not set, using test SQLite"
            export DATABASE_URL="sqlite+aiosqlite:///./test.db"
          fi
          python -c "import main; print('Backend imports OK')"

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install frontend dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Build frontend
        working-directory: ./frontend
        run: |
          npm run build || (echo "Build failed" && exit 1)

      - name: Upload frontend build artifact
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build
          path: frontend/build
          retention-days: 1

      - name: Build Docker images
        working-directory: .
        run: |
          docker build -t crm-backend:test ./backend
          echo "Docker build successful"

  deploy:
    needs: test-and-build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download frontend build artifact
        uses: actions/download-artifact@v4
        with:
          name: frontend-build
          path: frontend/build

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts
        run: |
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Create or update .env file on server
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} bash << 'ENV_SCRIPT'
            set -e
            DEPLOY_DIR="/opt/translations/translations-crm"
            # Перевіряємо чи директорія існує
            if [ ! -d "$DEPLOY_DIR" ]; then
              echo "Error: Directory $DEPLOY_DIR does not exist!"
              echo "Please create it on the server with:"
              echo "  sudo mkdir -p $DEPLOY_DIR"
              echo "  sudo chown -R $USER:$USER $DEPLOY_DIR"
              exit 1
            fi
            # Перевіряємо права доступу
            if [ ! -w "$DEPLOY_DIR" ]; then
              echo "Warning: Directory $DEPLOY_DIR is not writable, fixing permissions..."
              sudo chown -R $USER:$USER "$DEPLOY_DIR" 2>/dev/null || {
                echo "Warning: Cannot fix permissions, but continuing..."
              }
            fi
            cd "$DEPLOY_DIR" || {
              echo "Error: Cannot access directory $DEPLOY_DIR"
              exit 1
            }
            
            # Fix git permissions if needed (before any git operations)
            if [ -d ".git" ]; then
              echo "Ensuring git permissions are correct..."
              sudo chown -R $USER:$USER .git 2>/dev/null || {
                echo "Warning: Cannot fix .git ownership, but continuing..."
              }
              chmod -R u+w .git/objects .git/refs 2>/dev/null || {
                echo "Warning: Cannot fix .git subdirectories permissions, but continuing..."
              }
            fi
            
            # Якщо .env вже існує, зберігаємо його та оновлюємо тільки потрібні значення
            if [ -f .env ]; then
              echo "Existing .env file found, updating with GitHub Secrets..."
              # Зберігаємо існуючий .env як backup
              cp .env .env.backup
              
              # Оновлюємо значення з GitHub Secrets (якщо вони встановлені)
              [ -n "${{ secrets.POSTGRES_USER }}" ] && sed -i "s/^POSTGRES_USER=.*/POSTGRES_USER=${{ secrets.POSTGRES_USER }}/" .env || true
              [ -n "${{ secrets.POSTGRES_PASSWORD }}" ] && sed -i "s/^POSTGRES_PASSWORD=.*/POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}/" .env || true
              [ -n "${{ secrets.POSTGRES_DB }}" ] && sed -i "s/^POSTGRES_DB=.*/POSTGRES_DB=${{ secrets.POSTGRES_DB }}/" .env || true
              [ -n "${{ secrets.DATABASE_URL }}" ] && sed -i "s|^DATABASE_URL=.*|DATABASE_URL=${{ secrets.DATABASE_URL }}|" .env || true
              [ -n "${{ secrets.JWT_SECRET }}" ] && sed -i "s/^JWT_SECRET=.*/JWT_SECRET=${{ secrets.JWT_SECRET }}/" .env || true
              
              # Додаємо нові змінні якщо їх немає
              grep -q "^APP_ENV=" .env || echo "APP_ENV=prod" >> .env
              [ -n "${{ secrets.REDIS_URL }}" ] && grep -q "^REDIS_URL=" .env || echo "REDIS_URL=${{ secrets.REDIS_URL }}" >> .env || true
              [ -n "${{ secrets.FRONTEND_URL }}" ] && grep -q "^FRONTEND_URL=" .env || echo "FRONTEND_URL=${{ secrets.FRONTEND_URL }}" >> .env || true
              [ -n "${{ secrets.OPENAI_API_KEY }}" ] && grep -q "^OPENAI_API_KEY=" .env || echo "OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}" >> .env || true
              [ -n "${{ secrets.ENCRYPTION_KEY }}" ] && grep -q "^ENCRYPTION_KEY=" .env || echo "ENCRYPTION_KEY=${{ secrets.ENCRYPTION_KEY }}" >> .env || true
              [ -n "${{ secrets.WHATSAPP_API_TOKEN }}" ] && grep -q "^WHATSAPP_API_TOKEN=" .env || echo "WHATSAPP_API_TOKEN=${{ secrets.WHATSAPP_API_TOKEN }}" >> .env || true
              [ -n "${{ secrets.WHATSAPP_PHONE_NUMBER_ID }}" ] && grep -q "^WHATSAPP_PHONE_NUMBER_ID=" .env || echo "WHATSAPP_PHONE_NUMBER_ID=${{ secrets.WHATSAPP_PHONE_NUMBER_ID }}" >> .env || true
              [ -n "${{ secrets.STRIPE_SECRET_KEY }}" ] && grep -q "^STRIPE_SECRET_KEY=" .env || echo "STRIPE_SECRET_KEY=${{ secrets.STRIPE_SECRET_KEY }}" >> .env || true
              [ -n "${{ secrets.STRIPE_PUBLISHABLE_KEY }}" ] && grep -q "^STRIPE_PUBLISHABLE_KEY=" .env || echo "STRIPE_PUBLISHABLE_KEY=${{ secrets.STRIPE_PUBLISHABLE_KEY }}" >> .env || true
            else
              echo "Creating new .env file from GitHub Secrets..."
              cat > .env << EOF
          POSTGRES_USER=${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_DB=${{ secrets.POSTGRES_DB }}
          DATABASE_URL=${{ secrets.DATABASE_URL }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          APP_ENV=prod
          REDIS_URL=${{ secrets.REDIS_URL }}
          FRONTEND_URL=${{ secrets.FRONTEND_URL }}
          OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
          ENCRYPTION_KEY=${{ secrets.ENCRYPTION_KEY }}
          WHATSAPP_API_TOKEN=${{ secrets.WHATSAPP_API_TOKEN }}
          WHATSAPP_PHONE_NUMBER_ID=${{ secrets.WHATSAPP_PHONE_NUMBER_ID }}
          STRIPE_SECRET_KEY=${{ secrets.STRIPE_SECRET_KEY }}
          STRIPE_PUBLISHABLE_KEY=${{ secrets.STRIPE_PUBLISHABLE_KEY }}
          EOF
            fi
          ENV_SCRIPT

      - name: Copy frontend build to server
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "mkdir -p /opt/translations/translations-crm/frontend/build"
          scp -r frontend/build/* ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/opt/translations/translations-crm/frontend/build/

      - name: Deploy to server
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} bash << 'DEPLOY_SCRIPT'
            set -e
            
            BASE_DIR="/opt/translations"
            DEPLOY_DIR="/opt/translations/translations-crm"
            
            # Перевіряємо чи базова директорія існує
            if [ ! -d "$BASE_DIR" ]; then
              echo "Error: Base directory $BASE_DIR does not exist!"
              exit 1
            fi
            
            # Перевіряємо чи робоча директорія існує
            if [ ! -d "$DEPLOY_DIR" ]; then
              echo "Error: Deploy directory $DEPLOY_DIR does not exist!"
              echo "Please clone the repository to $DEPLOY_DIR"
              exit 1
            fi
            
            # Перевіряємо права доступу
            if [ ! -w "$DEPLOY_DIR" ]; then
              echo "Warning: Directory $DEPLOY_DIR is not writable"
              ls -ld "$DEPLOY_DIR"
            fi
            
            cd "$DEPLOY_DIR" || {
              echo "Error: Cannot access directory $DEPLOY_DIR"
              exit 1
            }
            
            # Fix git permissions if needed
            if [ -d ".git" ]; then
              echo "Fixing git permissions..."
              # Fix ownership of .git directory
              sudo chown -R $USER:$USER .git 2>/dev/null || {
                echo "Warning: Cannot fix .git ownership, trying to continue..."
              }
              # Fix permissions for .git/objects
              chmod -R u+w .git/objects 2>/dev/null || {
                echo "Warning: Cannot fix .git/objects permissions, trying to continue..."
              }
              # Fix permissions for .git/refs
              chmod -R u+w .git/refs 2>/dev/null || {
                echo "Warning: Cannot fix .git/refs permissions, trying to continue..."
              }
            fi
            
            # Fix ownership of all files before git operations
            echo "Fixing file ownership..."
            sudo chown -R $USER:$USER "$DEPLOY_DIR" 2>/dev/null || {
              echo "Warning: Cannot fix file ownership, trying to continue..."
            }
            
            # Fix permissions for files that might be locked
            find "$DEPLOY_DIR" -type f -name "*.py" -exec chmod u+w {} \; 2>/dev/null || true
            
            # Pull latest code
            if [ -d ".git" ]; then
              echo "Pulling latest changes from git..."
              git fetch origin
              git reset --hard origin/main
            else
              echo "Error: .git directory not found in $DEPLOY_DIR"
              echo "Please ensure the repository is cloned correctly"
              exit 1
            fi
            
            # Створюємо директорію для frontend build якщо не існує
            mkdir -p frontend/build
            
            # Ensure .env exists (created in previous step)
            if [ ! -f .env ]; then
              echo "Error: .env file not found!"
              exit 1
            fi
            
            # Перевіряємо яка версія docker compose доступна
            if command -v docker-compose &> /dev/null; then
              DOCKER_COMPOSE_CMD="docker-compose"
              echo "Using docker-compose (standalone)"
            elif docker compose version &> /dev/null 2>&1; then
              DOCKER_COMPOSE_CMD="docker compose"
              echo "Using docker compose (plugin)"
            else
              echo "Error: docker-compose not found. Please install docker-compose or use Docker with compose plugin."
              echo "Trying docker compose as fallback..."
              DOCKER_COMPOSE_CMD="docker compose"
            fi
            
            # Перевіряємо що команда працює
            $DOCKER_COMPOSE_CMD --version || {
              echo "Error: docker-compose command failed. Please check Docker installation."
              exit 1
            }
            
            # Зупиняємо та видаляємо тільки контейнери translations-crm (без видалення volumes - база даних зберігається)
            echo "Stopping existing crm_translations containers..."
            $DOCKER_COMPOSE_CMD -f docker-compose.production.yml down --remove-orphans || true
            
            # Додатково перевіряємо та видаляємо тільки контейнери translations-crm які можуть займати порти
            echo "Checking for crm_translations containers..."
            docker ps -a --filter "name=crm_translations" --format "{{.Names}}" | while read container; do
              if [ -n "$container" ]; then
                echo "Removing container: $container"
                docker rm -f "$container" || true
              fi
            done
            
            # Невелика затримка для звільнення портів
            sleep 2
            
            # Очищаємо BuildKit кеш для уникнення помилок snapshot (не торкаємося volumes та контейнерів)
            echo "Cleaning Docker BuildKit cache to prevent snapshot errors..."
            docker builder prune -f || echo "Warning: Failed to prune build cache, continuing anyway..."
            
            # Build and start new containers (volumes зберігаються автоматично)
            echo "Building and starting new containers..."
            if ! $DOCKER_COMPOSE_CMD -f docker-compose.production.yml up -d --build --remove-orphans; then
              echo "❌ Docker compose up failed! Trying with --no-cache..."
              echo "Cleaning build cache again and retrying..."
              docker builder prune -af || true
              if ! $DOCKER_COMPOSE_CMD -f docker-compose.production.yml build --no-cache; then
                echo "❌ Docker build failed even with --no-cache!"
                echo "Checking docker-compose logs..."
                $DOCKER_COMPOSE_CMD -f docker-compose.production.yml logs --tail 50 || true
                exit 1
              fi
              # Якщо build успішний, запускаємо контейнери
              if ! $DOCKER_COMPOSE_CMD -f docker-compose.production.yml up -d --remove-orphans; then
                echo "❌ Docker compose up failed after rebuild!"
                $DOCKER_COMPOSE_CMD -f docker-compose.production.yml logs --tail 50 || true
                exit 1
              fi
            fi
            
            # Check if containers started successfully
            echo "Checking container status..."
            sleep 10
            echo "=== All containers ==="
            docker ps -a --filter "name=crm_translations" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" || true
            echo ""
            echo "=== Docker Compose Status ==="
            $DOCKER_COMPOSE_CMD -f docker-compose.production.yml ps || true
            echo ""
            
            # Check backend container specifically
            BACKEND_CONTAINER=$(docker ps --filter "name=crm_translations_backend" --format "{{.Names}}" | head -1)
            if [ -z "$BACKEND_CONTAINER" ]; then
              echo "❌ Backend container failed to start!"
              echo ""
              echo "=== Checking stopped containers ==="
              docker ps -a --filter "name=crm_translations_backend" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" || true
              echo ""
              echo "=== Backend Container Logs ==="
              docker logs crm_translations_backend --tail 100 2>&1 || echo "Container doesn't exist"
              echo ""
              echo "=== Postgres Container Status ==="
              docker ps -a --filter "name=crm_translations_postgres" --format "table {{.Names}}\t{{.Status}}" || true
              echo ""
              echo "=== Docker Compose Logs ==="
              $DOCKER_COMPOSE_CMD -f docker-compose.production.yml logs backend --tail 50 || true
              exit 1
            fi
            
            echo "✅ Backend container is running: $BACKEND_CONTAINER"
            
            # Wait for services to initialize
            echo "Waiting for services to initialize..."
            sleep 25
            
            # Clean up old images
            docker image prune -f
            
            echo "Deployment completed successfully"
          DEPLOY_SCRIPT

      - name: Health check
        run: |
          BACKEND_PORT="${{ secrets.BACKEND_PORT }}"
          if [ -z "$BACKEND_PORT" ]; then
            BACKEND_PORT="8002"  # Оновлено з 8001 на 8002 (8001 зайнятий atbalance)
          fi
          
          SERVER_URL="http://${{ secrets.SERVER_HOST }}:$BACKEND_PORT"
          MAX_RETRIES=10
          RETRY_DELAY=5
          
          echo "Waiting for backend to be ready..."
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Health check attempt $i/$MAX_RETRIES..."
            
            # Try /health endpoint first (simpler, faster)
            if curl -f -s --max-time 5 "$SERVER_URL/health" > /dev/null 2>&1; then
              echo "✅ Health check passed (using /health endpoint)"
              curl -s "$SERVER_URL/health" | head -20
              exit 0
            fi
            
            # Fallback to / endpoint
            if curl -f -s --max-time 5 "$SERVER_URL/" > /dev/null 2>&1; then
              echo "✅ Health check passed (using / endpoint)"
              curl -s "$SERVER_URL/" | head -20
              exit 0
            fi
            
            if [ $i -lt $MAX_RETRIES ]; then
              echo "⏳ Backend not ready yet, waiting ${RETRY_DELAY}s..."
              sleep $RETRY_DELAY
            fi
          done
          
          echo "❌ Health check failed after $MAX_RETRIES attempts"
          echo ""
          echo "=== Getting diagnostics from server ==="
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} bash << 'DIAG_SCRIPT'
            DEPLOY_DIR="/opt/translations/translations-crm"
            cd "$DEPLOY_DIR" || exit 1
            
            # Перевіряємо яка версія docker compose доступна
            if command -v docker-compose &> /dev/null; then
              DOCKER_COMPOSE_CMD="docker-compose"
            elif docker compose version &> /dev/null 2>&1; then
              DOCKER_COMPOSE_CMD="docker compose"
            else
              DOCKER_COMPOSE_CMD="docker compose"
            fi
            
            echo "=== Container Status ==="
            docker ps -a --filter "name=crm_translations" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" || true
            echo ""
            echo "=== Docker Compose Status ==="
            $DOCKER_COMPOSE_CMD -f docker-compose.production.yml ps || true
            echo ""
            echo "=== Backend Container Logs ==="
            docker logs crm_translations_backend --tail 100 2>&1 || echo "Container not found"
            echo ""
            echo "=== Postgres Container Logs ==="
            docker logs crm_translations_postgres --tail 50 2>&1 || echo "Postgres container not found"
            echo ""
            echo "=== Network Status ==="
            docker network ls | grep crm_translations || true
            echo ""
            echo "=== Port Status ==="
            netstat -tuln | grep -E ":(8002|5435|8082)" || ss -tuln | grep -E ":(8002|5435|8082)" || true
          DIAG_SCRIPT
          exit 1

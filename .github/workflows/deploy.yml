name: Deploy to Production

on:
  push:
    branches:
      - main
  workflow_dispatch: # Дозволяє запускати вручну через GitHub Actions UI

jobs:
  test-and-build:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Cache Python dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('backend/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install Python dependencies
        working-directory: ./backend
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-asyncio httpx aiosqlite asyncpg

      - name: Run Python linting
        working-directory: ./backend
        run: |
          pip install flake8 black
          # Check code style (non-blocking)
          black --check . || true
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics || true

      - name: Test backend imports
        working-directory: ./backend
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          JWT_SECRET: ${{ secrets.JWT_SECRET || 'test-secret-key-for-ci' }}
          APP_ENV: test
        run: |
          if [ -z "$DATABASE_URL" ]; then
            echo "Warning: DATABASE_URL not set, using test SQLite"
            export DATABASE_URL="sqlite+aiosqlite:///./test.db"
          fi
          python -c "import main; print('Backend imports OK')"

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install frontend dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Build frontend
        working-directory: ./frontend
        run: |
          npm run build || (echo "Build failed" && exit 1)

      - name: Upload frontend build artifact
        uses: actions/upload-artifact@v4
        with:
          name: frontend-build
          path: frontend/build
          retention-days: 1

      - name: Build Docker images
        working-directory: .
        run: |
          docker build -t crm-backend:test ./backend
          echo "Docker build successful"

  deploy:
    needs: test-and-build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download frontend build artifact
        uses: actions/download-artifact@v4
        with:
          name: frontend-build
          path: frontend/build

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts
        run: |
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Create or update .env file on server
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} bash << 'ENV_SCRIPT'
            set -e
            DEPLOY_DIR="/opt/translations/translations-crm"
            # Перевіряємо чи директорія існує
            if [ ! -d "$DEPLOY_DIR" ]; then
              echo "Error: Directory $DEPLOY_DIR does not exist!"
              echo "Please create it on the server with:"
              echo "  sudo mkdir -p $DEPLOY_DIR"
              echo "  sudo chown -R $USER:$USER $DEPLOY_DIR"
              exit 1
            fi
            # Перевіряємо права доступу
            if [ ! -w "$DEPLOY_DIR" ]; then
              echo "Warning: Directory $DEPLOY_DIR is not writable, fixing permissions..."
              sudo chown -R $USER:$USER "$DEPLOY_DIR" 2>/dev/null || {
                echo "Warning: Cannot fix permissions, but continuing..."
              }
            fi
            cd "$DEPLOY_DIR" || {
              echo "Error: Cannot access directory $DEPLOY_DIR"
              exit 1
            }
            
            # Якщо .env вже існує, зберігаємо його та оновлюємо тільки потрібні значення
            if [ -f .env ]; then
              echo "Existing .env file found, updating with GitHub Secrets..."
              # Зберігаємо існуючий .env як backup
              cp .env .env.backup
              
              # Оновлюємо значення з GitHub Secrets (якщо вони встановлені)
              [ -n "${{ secrets.POSTGRES_USER }}" ] && sed -i "s/^POSTGRES_USER=.*/POSTGRES_USER=${{ secrets.POSTGRES_USER }}/" .env || true
              [ -n "${{ secrets.POSTGRES_PASSWORD }}" ] && sed -i "s/^POSTGRES_PASSWORD=.*/POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}/" .env || true
              [ -n "${{ secrets.POSTGRES_DB }}" ] && sed -i "s/^POSTGRES_DB=.*/POSTGRES_DB=${{ secrets.POSTGRES_DB }}/" .env || true
              [ -n "${{ secrets.DATABASE_URL }}" ] && sed -i "s|^DATABASE_URL=.*|DATABASE_URL=${{ secrets.DATABASE_URL }}|" .env || true
              [ -n "${{ secrets.JWT_SECRET }}" ] && sed -i "s/^JWT_SECRET=.*/JWT_SECRET=${{ secrets.JWT_SECRET }}/" .env || true
              
              # Додаємо нові змінні якщо їх немає
              grep -q "^APP_ENV=" .env || echo "APP_ENV=prod" >> .env
            else
              echo "Creating new .env file from GitHub Secrets..."
              cat > .env << EOF
          POSTGRES_USER=${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_DB=${{ secrets.POSTGRES_DB }}
          DATABASE_URL=${{ secrets.DATABASE_URL }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          APP_ENV=prod
          REDIS_URL=${{ secrets.REDIS_URL }}
          FRONTEND_URL=${{ secrets.FRONTEND_URL }}
          OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
          EOF
            fi
          ENV_SCRIPT

      - name: Copy frontend build to server
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "mkdir -p /opt/translations/translations-crm/frontend/build"
          scp -r frontend/build/* ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/opt/translations/translations-crm/frontend/build/

      - name: Deploy to server
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} bash << 'DEPLOY_SCRIPT'
            set -e
            
            BASE_DIR="/opt/translations"
            DEPLOY_DIR="/opt/translations/translations-crm"
            
            # Перевіряємо чи базова директорія існує
            if [ ! -d "$BASE_DIR" ]; then
              echo "Error: Base directory $BASE_DIR does not exist!"
              exit 1
            fi
            
            # Перевіряємо чи робоча директорія існує
            if [ ! -d "$DEPLOY_DIR" ]; then
              echo "Error: Deploy directory $DEPLOY_DIR does not exist!"
              echo "Please clone the repository to $DEPLOY_DIR"
              exit 1
            fi
            
            # Перевіряємо права доступу
            if [ ! -w "$DEPLOY_DIR" ]; then
              echo "Warning: Directory $DEPLOY_DIR is not writable"
              ls -ld "$DEPLOY_DIR"
            fi
            
            cd "$DEPLOY_DIR" || {
              echo "Error: Cannot access directory $DEPLOY_DIR"
              exit 1
            }
            
            # Pull latest code
            if [ -d ".git" ]; then
              echo "Pulling latest changes from git..."
              git fetch origin
              git reset --hard origin/main
            else
              echo "Error: .git directory not found in $DEPLOY_DIR"
              echo "Please ensure the repository is cloned correctly"
              exit 1
            fi
            
            # Створюємо директорію для frontend build якщо не існує
            mkdir -p frontend/build
            
            # Ensure .env exists (created in previous step)
            if [ ! -f .env ]; then
              echo "Error: .env file not found!"
              exit 1
            fi
            
            # Перевіряємо яка версія docker compose доступна
            if command -v docker-compose &> /dev/null; then
              DOCKER_COMPOSE_CMD="docker-compose"
              echo "Using docker-compose (standalone)"
            elif docker compose version &> /dev/null 2>&1; then
              DOCKER_COMPOSE_CMD="docker compose"
              echo "Using docker compose (plugin)"
            else
              echo "Error: docker-compose not found. Please install docker-compose or use Docker with compose plugin."
              echo "Trying docker compose as fallback..."
              DOCKER_COMPOSE_CMD="docker compose"
            fi
            
            # Перевіряємо що команда працює
            $DOCKER_COMPOSE_CMD --version || {
              echo "Error: docker-compose command failed. Please check Docker installation."
              exit 1
            }
            
            # Зупиняємо та видаляємо тільки контейнери translations-crm (без видалення volumes - база даних зберігається)
            echo "Stopping existing crm_translations containers..."
            $DOCKER_COMPOSE_CMD -f docker-compose.production.yml down --remove-orphans || true
            
            # Додатково перевіряємо та видаляємо тільки контейнери translations-crm які можуть займати порти
            echo "Checking for crm_translations containers..."
            docker ps -a --filter "name=crm_translations" --format "{{.Names}}" | while read container; do
              if [ -n "$container" ]; then
                echo "Removing container: $container"
                docker rm -f "$container" || true
              fi
            done
            
            # Невелика затримка для звільнення портів
            sleep 2
            
            # Build and start new containers (volumes зберігаються автоматично)
            echo "Building and starting new containers..."
            $DOCKER_COMPOSE_CMD -f docker-compose.production.yml up -d --build --remove-orphans
            
            # Wait for services to be healthy
            sleep 15
            
            # Clean up old images
            docker image prune -f
            
            echo "Deployment completed successfully"
          DEPLOY_SCRIPT

      - name: Health check
        run: |
          BACKEND_PORT="${{ secrets.BACKEND_PORT }}"
          if [ -z "$BACKEND_PORT" ]; then
            BACKEND_PORT="8002"  # Оновлено з 8001 на 8002 (8001 зайнятий atbalance)
          fi
          
          SERVER_URL="http://${{ secrets.SERVER_HOST }}:$BACKEND_PORT"
          MAX_RETRIES=10
          RETRY_DELAY=5
          
          echo "Waiting for backend to be ready..."
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Health check attempt $i/$MAX_RETRIES..."
            
            # Try /health endpoint first (simpler, faster)
            if curl -f -s --max-time 5 "$SERVER_URL/health" > /dev/null 2>&1; then
              echo "✅ Health check passed (using /health endpoint)"
              curl -s "$SERVER_URL/health" | head -20
              exit 0
            fi
            
            # Fallback to / endpoint
            if curl -f -s --max-time 5 "$SERVER_URL/" > /dev/null 2>&1; then
              echo "✅ Health check passed (using / endpoint)"
              curl -s "$SERVER_URL/" | head -20
              exit 0
            fi
            
            if [ $i -lt $MAX_RETRIES ]; then
              echo "⏳ Backend not ready yet, waiting ${RETRY_DELAY}s..."
              sleep $RETRY_DELAY
            fi
          done
          
          echo "❌ Health check failed after $MAX_RETRIES attempts"
          echo "Checking container status..."
          docker ps -a --filter "name=crm_translations_backend" || true
          echo "Checking logs..."
          docker logs crm_translations_backend --tail 50 || true
          exit 1

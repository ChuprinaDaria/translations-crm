name: Deploy to Production

on:
  push:
    branches:
      - main
  workflow_dispatch: # Дозволяє запускати вручну через GitHub Actions UI

jobs:
  test-and-build:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Cache Python dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('backend/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install Python dependencies
        working-directory: ./backend
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-asyncio httpx aiosqlite asyncpg

      - name: Run Python linting
        working-directory: ./backend
        run: |
          pip install flake8 black
          # Check code style (non-blocking)
          black --check . || true
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics || true

      - name: Test backend imports
        working-directory: ./backend
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          JWT_SECRET: ${{ secrets.JWT_SECRET || 'test-secret-key-for-ci' }}
          APP_ENV: test
        run: |
          if [ -z "$DATABASE_URL" ]; then
            echo "Warning: DATABASE_URL not set, using test SQLite"
            export DATABASE_URL="sqlite+aiosqlite:///./test.db"
          fi
          python -c "import main; print('Backend imports OK')"

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install frontend dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Run frontend linting
        working-directory: ./frontend
        run: |
          npm run build || (echo "Build failed" && exit 1)

      - name: Build Docker images
        working-directory: .
        run: |
          docker build -t crm-backend:test ./backend
          echo "Docker build successful"

  deploy:
    needs: test-and-build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts
        run: |
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Create or update .env file on server
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} bash << 'ENV_SCRIPT'
            set -e
            DEPLOY_DIR="/opt/translations/translations-crm"
            # Перевіряємо чи директорія існує
            if [ ! -d "$DEPLOY_DIR" ]; then
              echo "Error: Directory $DEPLOY_DIR does not exist!"
              echo "Please create it on the server with:"
              echo "  sudo mkdir -p $DEPLOY_DIR"
              echo "  sudo chown -R $USER:$USER $DEPLOY_DIR"
              exit 1
            fi
            # Перевіряємо права доступу
            if [ ! -w "$DEPLOY_DIR" ]; then
              echo "Warning: Directory $DEPLOY_DIR is not writable, fixing permissions..."
              sudo chown -R $USER:$USER "$DEPLOY_DIR" 2>/dev/null || {
                echo "Warning: Cannot fix permissions, but continuing..."
              }
            fi
            cd "$DEPLOY_DIR" || {
              echo "Error: Cannot access directory $DEPLOY_DIR"
              exit 1
            }
            
            # Якщо .env вже існує, зберігаємо його та оновлюємо тільки потрібні значення
            if [ -f .env ]; then
              echo "Existing .env file found, updating with GitHub Secrets..."
              # Зберігаємо існуючий .env як backup
              cp .env .env.backup
              
              # Оновлюємо значення з GitHub Secrets (якщо вони встановлені)
              [ -n "${{ secrets.POSTGRES_USER }}" ] && sed -i "s/^POSTGRES_USER=.*/POSTGRES_USER=${{ secrets.POSTGRES_USER }}/" .env || true
              [ -n "${{ secrets.POSTGRES_PASSWORD }}" ] && sed -i "s/^POSTGRES_PASSWORD=.*/POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}/" .env || true
              [ -n "${{ secrets.POSTGRES_DB }}" ] && sed -i "s/^POSTGRES_DB=.*/POSTGRES_DB=${{ secrets.POSTGRES_DB }}/" .env || true
              [ -n "${{ secrets.DATABASE_URL }}" ] && sed -i "s|^DATABASE_URL=.*|DATABASE_URL=${{ secrets.DATABASE_URL }}|" .env || true
              [ -n "${{ secrets.JWT_SECRET }}" ] && sed -i "s/^JWT_SECRET=.*/JWT_SECRET=${{ secrets.JWT_SECRET }}/" .env || true
              
              # Додаємо нові змінні якщо їх немає
              grep -q "^APP_ENV=" .env || echo "APP_ENV=prod" >> .env
            else
              echo "Creating new .env file from GitHub Secrets..."
              cat > .env << EOF
          POSTGRES_USER=${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_DB=${{ secrets.POSTGRES_DB }}
          DATABASE_URL=${{ secrets.DATABASE_URL }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          APP_ENV=prod
          REDIS_URL=${{ secrets.REDIS_URL }}
          FRONTEND_URL=${{ secrets.FRONTEND_URL }}
          OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
          EOF
            fi
          ENV_SCRIPT

      - name: Copy frontend build to server
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} "mkdir -p /opt/translations/translations-crm/frontend/build"
          scp -r frontend/build/* ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:/opt/translations/translations-crm/frontend/build/

      - name: Deploy to server
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} bash << 'DEPLOY_SCRIPT'
            set -e
            
            BASE_DIR="/opt/translations"
            DEPLOY_DIR="/opt/translations/translations-crm"
            
            # Перевіряємо чи базова директорія існує
            if [ ! -d "$BASE_DIR" ]; then
              echo "Error: Base directory $BASE_DIR does not exist!"
              exit 1
            fi
            
            # Перевіряємо чи робоча директорія існує
            if [ ! -d "$DEPLOY_DIR" ]; then
              echo "Error: Deploy directory $DEPLOY_DIR does not exist!"
              echo "Please clone the repository to $DEPLOY_DIR"
              exit 1
            fi
            
            # Перевіряємо права доступу
            if [ ! -w "$DEPLOY_DIR" ]; then
              echo "Warning: Directory $DEPLOY_DIR is not writable"
              ls -ld "$DEPLOY_DIR"
            fi
            
            cd "$DEPLOY_DIR" || {
              echo "Error: Cannot access directory $DEPLOY_DIR"
              exit 1
            }
            
            # Pull latest code
            if [ -d ".git" ]; then
              echo "Pulling latest changes from git..."
              git fetch origin
              git reset --hard origin/main
            else
              echo "Error: .git directory not found in $DEPLOY_DIR"
              echo "Please ensure the repository is cloned correctly"
              exit 1
            fi
            
            # Створюємо директорію для frontend build якщо не існує
            mkdir -p frontend/build
            
            # Ensure .env exists (created in previous step)
            if [ ! -f .env ]; then
              echo "Error: .env file not found!"
              exit 1
            fi
            
            # Stop existing containers (без видалення volumes - база даних зберігається)
            docker-compose -f docker-compose.production.yml down || true
            
            # Build and start new containers (volumes зберігаються автоматично)
            docker-compose -f docker-compose.production.yml up -d --build
            
            # Wait for services to be healthy
            sleep 15
            
            # Clean up old images
            docker image prune -f
            
            echo "Deployment completed successfully"
          DEPLOY_SCRIPT

      - name: Health check
        run: |
          sleep 15
          BACKEND_PORT="${{ secrets.BACKEND_PORT }}"
          if [ -z "$BACKEND_PORT" ]; then
            BACKEND_PORT="8001"
          fi
          curl -f http://${{ secrets.SERVER_HOST }}:$BACKEND_PORT/docs || (echo "Health check failed" && exit 1)
          echo "Health check passed"

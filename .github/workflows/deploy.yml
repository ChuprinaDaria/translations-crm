name: Deploy to Production

on:
  push:
    branches:
      - main

jobs:
  test-and-build:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Cache Python dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('backend/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install Python dependencies
        working-directory: ./backend
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-asyncio httpx

      - name: Run Python linting
        working-directory: ./backend
        run: |
          pip install flake8 black
          # Check code style (non-blocking)
          black --check . || true
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics || true

      - name: Test backend imports
        working-directory: ./backend
        run: |
          python -c "import main; print('Backend imports OK')"

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install frontend dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Run frontend linting
        working-directory: ./frontend
        run: |
          npm run build || (echo "Build failed" && exit 1)

      - name: Build Docker images
        working-directory: .
        run: |
          docker build -t crm-backend:test ./backend
          echo "Docker build successful"

  deploy:
    needs: test-and-build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts
        run: |
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Create or update .env file on server
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} bash << 'ENV_SCRIPT'
            set -e
            DEPLOY_DIR="/opt/translations/translations-crm"
            mkdir -p $DEPLOY_DIR
            cd $DEPLOY_DIR
            
            # Якщо .env вже існує, зберігаємо його та оновлюємо тільки потрібні значення
            if [ -f .env ]; then
              echo "Existing .env file found, updating with GitHub Secrets..."
              # Зберігаємо існуючий .env як backup
              cp .env .env.backup
              
              # Оновлюємо значення з GitHub Secrets (якщо вони встановлені)
              [ -n "${{ secrets.POSTGRES_USER }}" ] && sed -i "s/^POSTGRES_USER=.*/POSTGRES_USER=${{ secrets.POSTGRES_USER }}/" .env || true
              [ -n "${{ secrets.POSTGRES_PASSWORD }}" ] && sed -i "s/^POSTGRES_PASSWORD=.*/POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}/" .env || true
              [ -n "${{ secrets.POSTGRES_DB }}" ] && sed -i "s/^POSTGRES_DB=.*/POSTGRES_DB=${{ secrets.POSTGRES_DB }}/" .env || true
              [ -n "${{ secrets.DATABASE_URL }}" ] && sed -i "s|^DATABASE_URL=.*|DATABASE_URL=${{ secrets.DATABASE_URL }}|" .env || true
              [ -n "${{ secrets.JWT_SECRET }}" ] && sed -i "s/^JWT_SECRET=.*/JWT_SECRET=${{ secrets.JWT_SECRET }}/" .env || true
              
              # Додаємо нові змінні якщо їх немає
              grep -q "^APP_ENV=" .env || echo "APP_ENV=prod" >> .env
            else
              echo "Creating new .env file from GitHub Secrets..."
              cat > .env << EOF
          POSTGRES_USER=${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_DB=${{ secrets.POSTGRES_DB }}
          DATABASE_URL=${{ secrets.DATABASE_URL }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          APP_ENV=prod
          REDIS_URL=${{ secrets.REDIS_URL }}
          FRONTEND_URL=${{ secrets.FRONTEND_URL }}
          OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}
          EOF
            fi
          ENV_SCRIPT

      - name: Deploy to server
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} bash << 'DEPLOY_SCRIPT'
            set -e
            
            DEPLOY_DIR="/opt/translations"
            mkdir -p $DEPLOY_DIR
            cd $DEPLOY_DIR
            
            # Pull latest code
            if [ -d ".git" ]; then
              git fetch origin
              git reset --hard origin/main
            else
              if [ -d "translations-crm" ]; then
                rm -rf translations-crm
              fi
              git clone ${{ secrets.REPO_URL }} .
            fi
            
            cd $DEPLOY_DIR/translations-crm
            
            # Ensure .env exists (created in previous step)
            if [ ! -f .env ]; then
              echo "Error: .env file not found!"
              exit 1
            fi
            
            # Build frontend
            cd frontend
            if [ ! -d "node_modules" ]; then
              npm ci
            else
              npm ci
            fi
            npm run build
            cd ..
            
            # Stop existing containers
            docker-compose -f docker-compose.production.yml down || true
            
            # Build and start new containers
            docker-compose -f docker-compose.production.yml up -d --build
            
            # Wait for services to be healthy
            sleep 15
            
            # Clean up old images
            docker image prune -f
            
            echo "Deployment completed successfully"
          DEPLOY_SCRIPT

      - name: Health check
        run: |
          sleep 15
          BACKEND_PORT="${{ secrets.BACKEND_PORT }}"
          if [ -z "$BACKEND_PORT" ]; then
            BACKEND_PORT="8001"
          fi
          curl -f http://${{ secrets.SERVER_HOST }}:$BACKEND_PORT/docs || (echo "Health check failed" && exit 1)
          echo "Health check passed"
